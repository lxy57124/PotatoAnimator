<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PotatoAnimator - 土豆动画师 (在线版)</title>
    
    <!-- 1. 样式库 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. 核心依赖 (UMD 版本，稳定支持 GitHub Pages) -->
    <!-- React 核心 -->
    <script crossorigin src="https://unpkg.com/react@18.2.0/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.development.js"></script>
    <!-- 图标库 -->
    <script crossorigin src="https://unpkg.com/lucide-react@0.263.1/dist/umd/lucide-react.min.js"></script>
    <!-- Babel 编译器 (让浏览器能运行 JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body {
        margin: 0;
        background-color: #0f172a;
        color: white;
        font-family: 'Inter', system-ui, sans-serif;
      }
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #1e293b; }
      ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #64748b; }
      
      .loader {
        border: 3px solid rgba(255,255,255,0.1);
        border-radius: 50%;
        border-top: 3px solid #eab308;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
      }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "@google/genai": "https://esm.sh/@google/genai@^1.37.0",
    "lucide-react": "https://esm.sh/lucide-react@^0.562.0"
  }
}
</script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        /**************************************************************
         *  0. 全局变量与工具函数
         **************************************************************/
        const { useState, useEffect, useRef, forwardRef, useImperativeHandle } = React;
        const { createRoot } = ReactDOM;
        
        // 兼容处理：确保能获取到 Lucide 图标
        const Lucide = window.lucideReact || window.lucide;
        const { 
            Sparkles, Image: ImageIcon, RotateCcw, Info, Download, 
            Code: CodeIcon, X, Palette, Scan, Sliders, Activity, 
            Layers, Grid, Grid3X3, ArrowRight, Eraser, Eclipse, 
            Skull, Bomb, ArrowDownToLine, Key, Play 
        } = Lucide;

        // 默认土豆 SVG
        const DEFAULT_POTATO_SVG = `data:image/svg+xml;utf8,%3Csvg%20viewBox%3D%220%200%20200%20200%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M100%2040c-40%200-70%2030-70%2070%200%2050%2030%2080%2070%2080s70-30%2070-80c0-40-30-70-70-70z%22%20fill%3D%22%23eab308%22%2F%3E%3Ccircle%20cx%3D%2275%22%20cy%3D%22100%22%20r%3D%2210%22%20fill%3D%22black%22%2F%3E%3Ccircle%20cx%3D%22125%22%20cy%3D%22100%22%20r%3D%2210%22%20fill%3D%22black%22%2F%3E%3Cpath%20d%3D%22M90%20130%20q10%2010%2020%200%22%20stroke%3D%22black%22%20stroke-width%3D%225%22%20fill%3D%22none%22%2F%3E%3C%2Fsvg%3E`;

        const AnimationState = {
            IDLE: 'IDLE', WALK: 'WALK', ATTACK: 'ATTACK', HIT: 'HIT', DEATH: 'DEATH'
        };
        const STATE_LABELS = {
            IDLE: '待机 (Idle)', WALK: '行走 (Walk)', ATTACK: '攻击 (Attack)', HIT: '受击 (Hit)', DEATH: '死亡 (Death)'
        };

        const DEFAULT_CONFIGS = {
            IDLE: { speed: 1.5, squashAmount: 0.02, stretchAmount: 0.02, landSquash: 0.05, rotationMax: 0, bounceHeight: 5, wobbleSpeed: 1, jitterIntensity: 0, jitterSpeed: 0, shatterIntensity: 0, enableShadow: true, shadowOpacity: 0.2, shadowScale: 1.0, shadowOffsetY: 0 },
            WALK: { speed: 8, squashAmount: 0.1, stretchAmount: 0.05, landSquash: 0.15, rotationMax: 10, bounceHeight: 15, wobbleSpeed: 2, jitterIntensity: 0, jitterSpeed: 0, shatterIntensity: 0, enableShadow: true, shadowOpacity: 0.2, shadowScale: 1.0, shadowOffsetY: 0 },
            ATTACK: { speed: 15, squashAmount: 0.2, stretchAmount: 0.3, landSquash: 0.1, rotationMax: 5, bounceHeight: 0, wobbleSpeed: 4, jitterIntensity: 0, jitterSpeed: 0, shatterIntensity: 0, enableShadow: true, shadowOpacity: 0.2, shadowScale: 1.0, shadowOffsetY: 0 },
            HIT: { speed: 20, squashAmount: 0.3, stretchAmount: 0.1, landSquash: 0, rotationMax: 20, bounceHeight: 0, wobbleSpeed: 5, jitterIntensity: 0, jitterSpeed: 0, shatterIntensity: 0, enableShadow: true, shadowOpacity: 0.2, shadowScale: 1.0, shadowOffsetY: 0 },
            DEATH: { speed: 3, squashAmount: 0.6, stretchAmount: 0.9, landSquash: 0, rotationMax: 5, bounceHeight: 0, wobbleSpeed: 1.0, jitterIntensity: 15, jitterSpeed: 40, shatterIntensity: 0, enableShadow: true, shadowOpacity: 0.2, shadowScale: 1.0, shadowOffsetY: 0 }
        };

        const DEFAULT_EXPORT_CONFIG = {
            layout: 'GRID', cellWidth: 256, cellHeight: 256, frameCount: 16, fps: 12,
            chromaKey: { enabled: false, color: '#00ff00', tolerance: 20, feather: 5, spill: 50 }
        };

        /**************************************************************
         *  1. Gemini API 服务 (纯 Fetch 版，无 SDK，适合静态网页)
         **************************************************************/
        const resizeImage = (dataUrl, size) => {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');
                    if (!ctx) { resolve(dataUrl); return; }
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(img, 0, 0, size, size);
                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = () => resolve(dataUrl);
                img.src = dataUrl;
            });
        };

        const generateSprite = async (apiKey, prompt, bgColorDescription, targetSize) => {
            if (!apiKey) throw new Error("请输入 API Key");
            
            // 直接调用 REST API，避免引入复杂的 SDK
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image:generateContent?key=${apiKey}`;
            
            const payload = {
                contents: [{
                    parts: [{
                        text: `Create a 2D game sprite of ${prompt}. 
                               Style: Vector art, flat colors, thick outlines, cute, 'Brotato' or 'Vampire Survivors' style.
                               View: Front facing.
                               Background: ${bgColorDescription} background. Solid color, no patterns.
                               IMPORTANT: No shadow under feet, No UI, Centered.`
                    }]
                }]
            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errText = await response.text();
                throw new Error(`API 报错 (${response.status}): ${errText}`);
            }

            const data = await response.json();
            
            let base64Image = '';
            try {
                // 安全地解析返回结果
                if (data.candidates && data.candidates[0].content && data.candidates[0].content.parts) {
                   const part = data.candidates[0].content.parts.find(p => p.inlineData);
                   if (part) base64Image = part.inlineData.data;
                }
            } catch (e) {
                console.error(e);
            }

            if (!base64Image) throw new Error("生成成功，但未返回图片数据。请检查 Prompt 是否触发了安全限制。");
            
            return await resizeImage(`data:image/png;base64,${base64Image}`, targetSize);
        };

        /**************************************************************
         *  2. 碎片算法 (Voronoi 模拟)
         **************************************************************/
        const generateShards = (width, height, cols = 4, rows = 4) => {
            const shards = [];
            const cellW = width / cols;
            const cellH = height / rows;
            const vertices = [];
            
            for (let r = 0; r <= rows; r++) {
                const rowVerts = [];
                for (let c = 0; c <= cols; c++) {
                    let x = c * cellW;
                    let y = r * cellH;
                    if (r > 0 && r < rows && c > 0 && c < cols) {
                        x += (Math.random() - 0.5) * (cellW * 0.7);
                        y += (Math.random() - 0.5) * (cellH * 0.7);
                    }
                    rowVerts.push({x, y});
                }
                vertices.push(rowVerts);
            }

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const p1 = vertices[r][c];
                    const p2 = vertices[r][c+1];
                    const p3 = vertices[r+1][c+1];
                    const p4 = vertices[r+1][c];
                    const cx = (p1.x + p2.x + p3.x + p4.x) / 4;
                    const cy = (p1.y + p2.y + p3.y + p4.y) / 4;
                    const imgCenterX = width / 2;
                    const imgCenterY = height / 2;
                    const dirX = (cx - imgCenterX);
                    const dirY = (cy - imgCenterY);
                    const mag = Math.sqrt(dirX*dirX + dirY*dirY) || 1;
                    
                    shards.push({
                        points: [
                            {x: p1.x - cx, y: p1.y - cy},
                            {x: p2.x - cx, y: p2.y - cy},
                            {x: p3.x - cx, y: p3.y - cy},
                            {x: p4.x - cx, y: p4.y - cy},
                        ],
                        center: {x: cx - imgCenterX, y: cy - imgCenterY},
                        velocity: {
                            x: (dirX / mag) + (Math.random() - 0.5) * 0.5, 
                            y: (dirY / mag) + (Math.random() - 0.5) * 0.5 - 0.2
                        }, 
                        rotationSpeed: (Math.random() - 0.5) * 10
                    });
                }
            }
            return shards;
        };

        /**************************************************************
         *  3. 组件
         **************************************************************/
        const CanvasPreview = forwardRef(({ imageSrc, config, exportConfig, currentState }, ref) => {
            const canvasRef = useRef(null);
            const originalImageRef = useRef(new Image());
            const processedImageRef = useRef(null);
            const requestRef = useRef(0);
            const timeRef = useRef(0);
            const [viewMode, setViewMode] = useState('LIVE');
            const [isProcessing, setIsProcessing] = useState(false);
            const shardCache = useRef([]);

            useEffect(() => {
                if (config.shatterIntensity > 0 && originalImageRef.current.complete && originalImageRef.current.width > 0) {
                    shardCache.current = generateShards(originalImageRef.current.width, originalImageRef.current.height, 4, 4);
                }
            }, [config.shatterIntensity, imageSrc, isProcessing]);

            useEffect(() => {
                const processImage = () => {
                    const img = originalImageRef.current;
                    if (!img.complete || img.naturalWidth === 0) return;

                    if (!exportConfig.chromaKey.enabled) {
                        processedImageRef.current = img;
                        return;
                    }
                    setIsProcessing(true);
                    const w = img.naturalWidth;
                    const h = img.naturalHeight;
                    const canvas = document.createElement('canvas');
                    canvas.width = w;
                    canvas.height = h;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imgData = ctx.getImageData(0, 0, w, h);
                    const data = imgData.data;

                    const hex = exportConfig.chromaKey.color;
                    const keyR = parseInt(hex.slice(1, 3), 16);
                    const keyG = parseInt(hex.slice(3, 5), 16);
                    const keyB = parseInt(hex.slice(5, 7), 16);
                    const tolerance = exportConfig.chromaKey.tolerance;
                    const feather = exportConfig.chromaKey.feather;
                    const spillIntensity = exportConfig.chromaKey.spill / 100;
                    const smoothRange = Math.max(1, feather * 10);

                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i], g = data[i+1], b = data[i+2];
                        const dist = Math.sqrt((r - keyR)**2 + (g - keyG)**2 + (b - keyB)**2);
                        let alpha = 255;
                        if (dist > tolerance + smoothRange) alpha = 255;
                        else if (dist > tolerance) alpha = ((dist - tolerance) / smoothRange) * 255;
                        else alpha = 0;

                        if (alpha > 0 && spillIntensity > 0) {
                             if (keyG > keyR && keyG > keyB) {
                                if (g > (r + b) / 2) data[i+1] = g * (1 - spillIntensity) + ((r+b)/2) * spillIntensity;
                             } else if (keyB > keyR && keyB > keyG) {
                                if (b > (r + g) / 2) data[i+2] = b * (1 - spillIntensity) + ((r+g)/2) * spillIntensity;
                             }
                        }
                        data[i + 3] = alpha;
                    }
                    ctx.putImageData(imgData, 0, 0);
                    const newImg = new Image();
                    newImg.src = canvas.toDataURL();
                    newImg.onload = () => { processedImageRef.current = newImg; setIsProcessing(false); };
                };
                processImage();
            }, [imageSrc, exportConfig.chromaKey]);

            const drawSpriteFrame = (ctx, img, centerX, groundY, cellWidth, cellHeight, t, config) => {
                let scaleX = 1, scaleY = 1, rotation = 0, bounce = 0, grayscale = 0, offsetX = 0, deathProgress = 0;

                if (currentState === AnimationState.DEATH) {
                    const rawCycle = Math.sin(t * config.wobbleSpeed - Math.PI / 2);
                    const progress = Math.max(0, (rawCycle + 0.8) / 1.8);
                    deathProgress = Math.min(Math.max(progress, 0), 1);
                    scaleY = 1 - (deathProgress * config.stretchAmount);
                    scaleX = 1 + (deathProgress * config.squashAmount);
                    
                    if (deathProgress > 0 && deathProgress < 0.95) {
                        const shakeIntensity = (1 - deathProgress) * (config.jitterIntensity || 0); 
                        const shakeFreq = (config.jitterSpeed || 1);
                        const shakeVal = Math.sin(t * shakeFreq);
                        rotation = (shakeVal * shakeIntensity) * (Math.PI / 180);
                        offsetX = Math.cos(t * shakeFreq * 1.3) * (shakeIntensity * 0.5);
                    }
                    rotation += deathProgress * (config.rotationMax * Math.PI / 180);
                    grayscale = deathProgress * 100;
                } else {
                    const sineWave = Math.sin(t * config.wobbleSpeed);
                    const absSine = Math.abs(sineWave);
                    scaleX = 1 + (sineWave * config.squashAmount);
                    scaleY = 1 - (sineWave * config.stretchAmount);
                    
                    if (config.landSquash && config.landSquash > 0) {
                        const impactFactor = Math.pow(1 - absSine, 3);
                        scaleY -= impactFactor * config.landSquash;
                        scaleX += impactFactor * config.landSquash * 1.5;
                    }
                    rotation = Math.cos(t * config.wobbleSpeed) * (config.rotationMax * (Math.PI / 180));
                    bounce = absSine * config.bounceHeight;
                }

                const refSize = Math.min(cellWidth, cellHeight);
                const relativeScale = refSize / 200;
                const bouncePx = bounce * relativeScale;
                const yOffset = -bouncePx;

                if (config.enableShadow) {
                    ctx.save();
                    const dynamicScale = 1 - (bounce / 120);
                    let shadowScaleMult = 1, shadowAlphaMult = 1;
                    if (currentState === AnimationState.DEATH) {
                        shadowScaleMult = scaleX;
                        if (config.shatterIntensity > 0) shadowAlphaMult = 1 - deathProgress;
                    }
                    const finalScale = (config.shadowScale || 1.0) * dynamicScale * relativeScale * shadowScaleMult;
                    const offsetY = (config.shadowOffsetY || 0) * relativeScale;
                    ctx.translate(centerX, groundY + offsetY);
                    ctx.scale(finalScale, finalScale * 0.3);
                    ctx.fillStyle = `rgba(0,0,0,${(config.shadowOpacity ?? 0.2) * shadowAlphaMult})`;
                    ctx.beginPath(); ctx.arc(0, 0, 60, 0, Math.PI * 2); ctx.fill();
                    ctx.restore();
                }

                ctx.save();
                if (currentState === AnimationState.DEATH && grayscale > 0) {
                    ctx.filter = `grayscale(${grayscale}%) brightness(${100 - (grayscale * 0.2)}%) sepia(${grayscale * 0.3}%)`;
                }
                ctx.translate(centerX + offsetX, groundY + yOffset);
                ctx.rotate(rotation);
                ctx.scale(scaleX, scaleY);
                const drawSize = refSize * 0.8;

                if (currentState === AnimationState.DEATH && config.shatterIntensity > 0 && deathProgress > 0) {
                    let shards = shardCache.current;
                    if (shards.length === 0) shards = generateShards(img.width, img.height);
                    
                    shards.forEach(shard => {
                        const explosionMult = deathProgress * config.shatterIntensity * 5;
                        const ex = shard.velocity.x * explosionMult;
                        const ey = shard.velocity.y * explosionMult;
                        const er = shard.rotationSpeed * deathProgress * (Math.PI / 180);
                        const alpha = Math.max(0, 1 - (deathProgress * 1.5));
                        if (alpha <= 0.01) return;

                        ctx.save();
                        ctx.globalAlpha = alpha;
                        const scaleRatio = drawSize / img.width;
                        const currentShardX = (shard.center.x * scaleRatio) + ex;
                        const currentShardY = (shard.center.y * scaleRatio) + ey;
                        ctx.translate(currentShardX, currentShardY);
                        ctx.rotate(er);
                        ctx.beginPath();
                        shard.points.forEach((p, idx) => {
                            const px = p.x * scaleRatio;
                            const py = p.y * scaleRatio;
                            if (idx === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
                        });
                        ctx.closePath();
                        ctx.clip();
                        
                        const drawImgW = img.width * scaleRatio;
                        const drawImgH = img.height * scaleRatio;
                        ctx.drawImage(img, (-img.width / 2 * scaleRatio) - (shard.center.x * scaleRatio), (-img.height / 2 * scaleRatio) - (shard.center.y * scaleRatio), drawImgW, drawImgH);
                        ctx.restore();
                    });
                } else {
                    ctx.drawImage(img, -drawSize / 2, -drawSize, drawSize, drawSize);
                }
                ctx.restore();
            };

            useImperativeHandle(ref, () => ({
                downloadSpritesheet: () => {
                    const sourceImg = processedImageRef.current || originalImageRef.current;
                    if (!sourceImg.complete || sourceImg.naturalWidth === 0) return;
                    const { cellWidth, cellHeight, frameCount, layout } = exportConfig;
                    let cols, rows;
                    if (layout === 'HORIZONTAL') { cols = frameCount; rows = 1; }
                    else { cols = Math.ceil(Math.sqrt(frameCount)); rows = Math.ceil(frameCount / cols); }
                    
                    const offscreen = document.createElement('canvas');
                    offscreen.width = cols * cellWidth;
                    offscreen.height = rows * cellHeight;
                    const ctx = offscreen.getContext('2d');
                    const totalCycleTime = (Math.PI * 2) / (config.wobbleSpeed || 1);

                    for (let i = 0; i < frameCount; i++) {
                        const t = (i / frameCount) * totalCycleTime;
                        const col = i % cols;
                        const row = Math.floor(i / cols);
                        const centerX = (col * cellWidth) + (cellWidth / 2);
                        const groundY = (row * cellHeight) + (cellHeight * 0.85);
                        drawSpriteFrame(ctx, sourceImg, centerX, groundY, cellWidth, cellHeight, t, config);
                    }
                    const link = document.createElement('a');
                    link.download = `potato_${cellWidth}x${cellHeight}_${frameCount}.png`;
                    link.href = offscreen.toDataURL('image/png');
                    link.click();
                }
            }));

            useEffect(() => {
                originalImageRef.current.src = imageSrc;
                originalImageRef.current.onload = () => {
                    processedImageRef.current = originalImageRef.current;
                    shardCache.current = generateShards(originalImageRef.current.width, originalImageRef.current.height);
                };
            }, [imageSrc]);

            useEffect(() => {
                const render = () => {
                    const canvas = canvasRef.current;
                    const ctx = canvas?.getContext('2d');
                    const img = (processedImageRef.current && processedImageRef.current.complete) ? processedImageRef.current : originalImageRef.current;
                    if (!canvas || !ctx || !img.complete || img.naturalWidth === 0) {
                        requestRef.current = requestAnimationFrame(render); return;
                    }
                    const w = canvas.width, h = canvas.height;
                    ctx.clearRect(0, 0, w, h);

                    const size = 20;
                    for(let y=0; y<h; y+=size) {
                        for(let x=0; x<w; x+=size) {
                            ctx.fillStyle = ((x/size + y/size) % 2 === 0) ? '#0f172a' : '#1e293b';
                            ctx.fillRect(x, y, size, size);
                        }
                    }

                    if (viewMode === 'LIVE') {
                        timeRef.current += 0.016 * config.speed;
                        const previewSize = 250;
                        drawSpriteFrame(ctx, img, w/2, h/2+80, previewSize, previewSize, timeRef.current, config);
                    } else {
                        const { cellWidth, cellHeight, frameCount, layout } = exportConfig;
                        let cols, rows;
                        if (layout === 'HORIZONTAL') { cols = frameCount; rows = 1; }
                        else { cols = Math.ceil(Math.sqrt(frameCount)); rows = Math.ceil(frameCount / cols); }
                        const sheetW = cols * cellWidth, sheetH = rows * cellHeight;
                        const scale = Math.min(w / sheetW, h / sheetH, 1) * 0.9;
                        ctx.save();
                        ctx.translate((w - sheetW*scale)/2, (h - sheetH*scale)/2);
                        ctx.scale(scale, scale);
                        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2/scale; ctx.strokeRect(0, 0, sheetW, sheetH);
                        
                        const totalCycleTime = (Math.PI * 2) / (config.wobbleSpeed || 1);
                        for (let i = 0; i < frameCount; i++) {
                            const t = (i / frameCount) * totalCycleTime;
                            const col = i % cols, row = Math.floor(i / cols);
                            const cellX = col * cellWidth, cellY = row * cellHeight;
                            ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1/scale; ctx.strokeRect(cellX, cellY, cellWidth, cellHeight);
                            drawSpriteFrame(ctx, img, cellX+cellWidth/2, cellY+cellHeight*0.85, cellWidth, cellHeight, t, config);
                            ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.font = `${Math.min(cellWidth, cellHeight)*0.15}px monospace`;
                            ctx.fillText(i, cellX+4, cellY+Math.min(cellWidth, cellHeight)*0.15);
                        }
                        ctx.restore();
                    }
                    requestRef.current = requestAnimationFrame(render);
                };
                requestRef.current = requestAnimationFrame(render);
                return () => cancelAnimationFrame(requestRef.current);
            }, [viewMode, config, exportConfig, imageSrc, currentState]);

            return (
                <div className="relative w-full h-full bg-slate-900 rounded-xl overflow-hidden border border-slate-700 shadow-inner flex items-center justify-center">
                    <div className="absolute top-4 left-4 bg-slate-800/90 px-3 py-1.5 rounded-lg border border-slate-700 text-xs text-slate-400 font-mono pointer-events-none z-10 flex flex-col gap-1 backdrop-blur-sm">
                        <span className="flex items-center gap-2">
                            <span className={`w-2 h-2 rounded-full ${viewMode === 'LIVE' ? 'bg-green-500 animate-pulse' : 'bg-orange-500'}`}></span>
                            模式: {viewMode === 'LIVE' ? '实时' : '网格'}
                        </span>
                        <span className="text-yellow-500/90">{exportConfig.cellWidth}x{exportConfig.cellHeight} / {exportConfig.frameCount} 帧</span>
                        {exportConfig.chromaKey.enabled && <span className="text-pink-400 flex items-center gap-1">• 去背开启 {isProcessing && '...'}</span>}
                    </div>
                    <div className="absolute top-4 right-4 z-10 flex bg-slate-800 p-1 rounded-lg border border-slate-700">
                        <button onClick={() => setViewMode('LIVE')} className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-xs font-bold ${viewMode === 'LIVE' ? 'bg-blue-600 text-white' : 'text-slate-400 hover:bg-slate-700'}`}><Play className="w-3 h-3" /> 预览</button>
                        <button onClick={() => setViewMode('SHEET')} className={`flex items-center gap-2 px-3 py-1.5 rounded-md text-xs font-bold ${viewMode === 'SHEET' ? 'bg-blue-600 text-white' : 'text-slate-400 hover:bg-slate-700'}`}>{exportConfig.layout === 'GRID' ? <Grid3X3 className="w-3 h-3" /> : <ArrowRight className="w-3 h-3" />} 网格</button>
                    </div>
                    <canvas ref={canvasRef} width={800} height={600} className="w-full h-full object-contain" />
                </div>
            );
        });

        const App = () => {
            const [currentState, setCurrentState] = useState(AnimationState.IDLE);
            const [config, setConfig] = useState(DEFAULT_CONFIGS[AnimationState.IDLE]);
            const [exportConfig, setExportConfig] = useState(DEFAULT_EXPORT_CONFIG);
            const [prompt, setPrompt] = useState('');
            const [bgColor, setBgColor] = useState('Green Screen (Hex #00FF00)');
            const [genSize, setGenSize] = useState(512);
            const [spriteUrl, setSpriteUrl] = useState(DEFAULT_POTATO_SVG);
            const [isGenerating, setIsGenerating] = useState(false);
            const [error, setError] = useState(null);
            const [showCode, setShowCode] = useState(false);
            const [apiKey, setApiKey] = useState(() => localStorage.getItem('potato_api_key') || '');
            
            const canvasRef = useRef(null);

            const handleStateChange = (newState) => {
                setCurrentState(newState);
                setConfig(prev => ({...DEFAULT_CONFIGS[newState], enableShadow: prev.enableShadow, shadowOpacity: prev.shadowOpacity, shadowScale: prev.shadowScale, shadowOffsetY: prev.shadowOffsetY }));
            };

            const handleGenerate = async () => {
                if (!prompt.trim()) return;
                setIsGenerating(true); setError(null);
                try {
                    localStorage.setItem('potato_api_key', apiKey);
                    const url = await generateSprite(apiKey, prompt, bgColor, genSize);
                    setSpriteUrl(url);
                    if (bgColor.includes('#00FF00')) setExportConfig(p => ({...p, chromaKey: {...p.chromaKey, color: '#00ff00', enabled: true}}));
                    else if (bgColor.includes('White')) setExportConfig(p => ({...p, chromaKey: {...p.chromaKey, color: '#ffffff', enabled: true}}));
                    else if (bgColor.includes('Blue')) setExportConfig(p => ({...p, chromaKey: {...p.chromaKey, color: '#0000ff', enabled: true}}));
                    else if (bgColor.includes('Black')) setExportConfig(p => ({...p, chromaKey: {...p.chromaKey, color: '#000000', enabled: true}}));
                } catch (err) {
                    setError(err.message || "生成失败");
                } finally { setIsGenerating(false); }
            };

            const handleFileUpload = (e) => {
                const file = e.target.files?.[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => setSpriteUrl(ev.target.result);
                    reader.readAsDataURL(file);
                }
            };

            return (
                <div className="min-h-screen bg-slate-950 text-white flex flex-col font-sans">
                    <header className="bg-slate-900 border-b border-slate-800 p-4">
                        <div className="max-w-7xl mx-auto flex items-center justify-between">
                            <div className="flex items-center gap-3">
                                <div className="w-10 h-10 bg-yellow-500 rounded-lg flex items-center justify-center shadow-lg"><Sparkles className="text-slate-900 w-6 h-6" /></div>
                                <div>
                                    <h1 className="text-xl font-bold bg-gradient-to-r from-yellow-400 to-orange-500 bg-clip-text text-transparent">PotatoAnimator (离线版)</h1>
                                    <p className="text-xs text-slate-400">程序化动画工具</p>
                                </div>
                            </div>
                            <button onClick={() => setShowCode(true)} className="flex items-center gap-2 px-3 py-1.5 bg-slate-800 rounded-lg text-sm text-blue-400 border border-slate-700"><CodeIcon className="w-4 h-4"/> 引擎代码</button>
                        </div>
                    </header>

                    <main className="flex-1 max-w-7xl mx-auto w-full p-4 md:p-6 gap-6 grid grid-cols-1 lg:grid-cols-12 h-[calc(100vh-80px)]">
                        {/* 侧边栏 */}
                        <div className="lg:col-span-3 flex flex-col gap-4 h-full overflow-y-auto">
                            <div className="bg-slate-900 p-4 rounded-xl border border-slate-800 shadow-lg flex flex-col gap-3">
                                <h2 className="text-sm font-bold text-slate-300 flex items-center gap-2"><ImageIcon className="w-4 h-4" /> 图片来源</h2>
                                
                                <div className="flex items-center gap-2 bg-slate-800 border border-slate-700 rounded-lg p-2">
                                    <Key className="w-4 h-4 text-yellow-500 shrink-0" />
                                    <input type="password" placeholder="Gemini API Key" className="w-full bg-transparent text-xs outline-none text-white placeholder-slate-500" value={apiKey} onChange={(e) => setApiKey(e.target.value)} />
                                </div>

                                <div className="relative">
                                    <input type="text" placeholder="例如：一个愤怒的西兰花战士" className="w-full bg-slate-800 border border-slate-700 rounded-lg p-2 text-sm focus:ring-2 focus:ring-yellow-500 outline-none pr-14" value={prompt} onChange={(e) => setPrompt(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && handleGenerate()} />
                                    <button onClick={handleGenerate} disabled={isGenerating || !prompt} className="absolute right-1 top-1 bottom-1 bg-blue-600 hover:bg-blue-500 text-white px-3 rounded-md text-xs font-bold disabled:opacity-50">{isGenerating ? '...' : '生成'}</button>
                                </div>

                                <div className="grid grid-cols-2 gap-2">
                                    <select value={bgColor} onChange={(e) => setBgColor(e.target.value)} className="bg-slate-800 border border-slate-700 rounded p-1.5 text-xs text-slate-300 w-full">
                                        <option value="Pure White">Pure White</option>
                                        <option value="Green Screen (Hex #00FF00)">Green Screen</option>
                                        <option value="Blue Screen (Hex #0000FF)">Blue Screen</option>
                                        <option value="Black Screen">Black Screen</option>
                                    </select>
                                    <select value={genSize} onChange={(e) => setGenSize(parseInt(e.target.value))} className="bg-slate-800 border border-slate-700 rounded p-1.5 text-xs text-slate-300 w-full">
                                        <option value={128}>128x128</option>
                                        <option value={256}>256x256</option>
                                        <option value={512}>512x512</option>
                                    </select>
                                </div>

                                <label className="flex items-center justify-center w-full p-2 bg-slate-800 border border-slate-700 border-dashed rounded-lg cursor-pointer hover:bg-slate-750">
                                    <span className="text-xs text-slate-400">上传 PNG / JPG</span>
                                    <input type="file" className="hidden" accept="image/*" onChange={handleFileUpload} />
                                </label>
                                {error && <div className="p-2 bg-red-900/30 border border-red-800 rounded text-xs text-red-300">{error}</div>}
                            </div>

                            <div className="bg-slate-800 p-6 rounded-xl border border-slate-700 shadow-xl flex-1 flex flex-col gap-6 overflow-y-auto">
                                <div>
                                    <h3 className="text-sm font-bold text-slate-400 uppercase tracking-wider mb-3 flex items-center gap-2"><Activity className="w-4 h-4 text-yellow-400" /> 动画状态</h3>
                                    <div className="grid grid-cols-2 gap-2">
                                        {Object.values(AnimationState).map((state) => (
                                            <button key={state} onClick={() => handleStateChange(state)} className={`px-3 py-2 rounded-lg text-xs font-bold transition-all ${currentState === state ? 'bg-yellow-500 text-slate-900 shadow-lg scale-105' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'}`}>{STATE_LABELS[state]}</button>
                                        ))}
                                    </div>
                                </div>
                                <hr className="border-slate-700" />
                                
                                {currentState === AnimationState.DEATH && (
                                    <div className="bg-red-900/10 border border-red-500/30 rounded-xl p-4 space-y-4">
                                        <h3 className="text-sm font-bold text-red-400 uppercase tracking-wider flex items-center gap-2"><Skull className="w-4 h-4" /> 死亡特调</h3>
                                        <div className="space-y-2">
                                            <div className="flex justify-between text-xs font-medium"><span className="text-slate-300">震动幅度</span><span className="text-red-400">{config.jitterIntensity}</span></div>
                                            <input type="range" min="0" max="50" step="1" value={config.jitterIntensity} onChange={(e) => setConfig({...config, jitterIntensity: parseFloat(e.target.value)})} className="w-full h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-red-500" />
                                        </div>
                                        <div className="space-y-2">
                                            <div className="flex justify-between text-xs font-medium"><span className="text-slate-300">碎裂程度</span><span className="text-red-400">{config.shatterIntensity}</span></div>
                                            <input type="range" min="0" max="50" step="1" value={config.shatterIntensity} onChange={(e) => setConfig({...config, shatterIntensity: parseFloat(e.target.value)})} className="w-full h-1.5 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-red-500" />
                                        </div>
                                    </div>
                                )}

                                <div className="space-y-4">
                                    <h3 className="text-sm font-bold text-slate-400 uppercase tracking-wider flex items-center gap-2"><Sliders className="w-4 h-4 text-blue-400" /> 通用微调</h3>
                                    
                                    <div className="space-y-2">
                                        <div className="flex justify-between text-xs font-medium"><span className="text-slate-300">动画速度</span><span className="text-blue-400">{config.speed}</span></div>
                                        <input type="range" min="0" max="30" step="0.1" value={config.speed} onChange={(e) => setConfig({...config, speed: parseFloat(e.target.value)})} className="w-full h-1.5 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-blue-500" />
                                    </div>

                                    <div className="space-y-2">
                                        <div className="flex justify-between text-xs font-medium"><span className="text-green-300">挤压/宽度 (Squash)</span><span className="text-green-400">{config.squashAmount}</span></div>
                                        <input type="range" min="0" max={currentState === AnimationState.DEATH ? "1.0" : "0.5"} step="0.01" value={config.squashAmount} onChange={(e) => setConfig({...config, squashAmount: parseFloat(e.target.value)})} className="w-full h-1.5 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-green-500" />
                                    </div>

                                    {currentState !== AnimationState.DEATH && (
                                        <div className="space-y-2">
                                            <div className="flex justify-between text-xs font-medium"><span className="text-orange-300">落地重力 (Land Squash)</span><span className="text-orange-400">{config.landSquash}</span></div>
                                            <input type="range" min="0" max="0.5" step="0.01" value={config.landSquash} onChange={(e) => setConfig({...config, landSquash: parseFloat(e.target.value)})} className="w-full h-1.5 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-orange-500" />
                                        </div>
                                    )}
                                    
                                    <div className="space-y-2">
                                        <div className="flex justify-between text-xs font-medium"><span className="text-red-300">旋转角度</span><span className="text-red-400">{config.rotationMax}</span></div>
                                        <input type="range" min="0" max="90" step="1" value={config.rotationMax} onChange={(e) => setConfig({...config, rotationMax: parseFloat(e.target.value)})} className="w-full h-1.5 bg-slate-600 rounded-lg appearance-none cursor-pointer accent-red-500" />
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* 画布 */}
                        <div className="lg:col-span-9 h-full flex flex-col gap-4">
                            <div className="flex-1 min-h-0 relative rounded-xl overflow-hidden border border-slate-700 shadow-2xl bg-slate-900">
                                <CanvasPreview ref={canvasRef} imageSrc={spriteUrl} config={config} exportConfig={exportConfig} currentState={currentState} />
                                <div className="absolute bottom-4 right-4 flex gap-2">
                                    <button onClick={() => canvasRef.current?.downloadSpritesheet()} className="flex items-center gap-2 px-4 py-2 bg-yellow-500 hover:bg-yellow-400 text-slate-900 rounded-lg shadow-lg font-bold text-sm transition-transform hover:scale-105"><Download className="w-4 h-4" /> 下载 Unity 图集</button>
                                </div>
                            </div>
                        </div>
                    </main>

                    {showCode && (
                        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                            <div className="bg-slate-900 border border-slate-700 w-full max-w-2xl rounded-xl shadow-2xl overflow-hidden flex flex-col max-h-[90vh]">
                                <div className="flex items-center justify-between p-4 border-b border-slate-700 bg-slate-800">
                                    <h3 className="text-lg font-bold text-white">游戏引擎代码</h3>
                                    <button onClick={() => setShowCode(false)}><X className="w-5 h-5 text-slate-400 hover:text-white" /></button>
                                </div>
                                <div className="p-6 overflow-y-auto space-y-4 text-xs font-mono text-blue-200">
                                    <p>Unity C# 和 Godot GDScript 代码已隐藏，请参考完整版或询问AI获取。</p>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
